<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>设置 - 美化PCB</title>
    <style>
        :root {
            /* Light Theme Defaults */
            --primary: #4285f4;
            --primary-hover: #3367d6;
            --danger: #dc3545;
            --text: #333;
            --text-secondary: #666;
            --text-hint: #999;
            --border: #e0e0e0;
            --bg: #f5f7fa;
            --card-bg: #fff;
            --input-bg: #f9f9f9;
            --switch-bg: #ccc;
            --hover-bg: #f0f7ff;
            --scrollbar-thumb: #ccc;
        }

        /* Dark Theme Overrides */
        [data-theme="dark"] {
            --primary: #6ea1fc;
            --primary-hover: #8ab4f8;
            --danger: #e06060;
            --text: #e8eaed;
            --text-secondary: #9aa0a6;
            --text-hint: #5f6368;
            --border: #3c4043;
            --bg: #202124;
            --card-bg: #2d2e31;
            --input-bg: #171717;
            --switch-bg: #5f6368;
            --hover-bg: #3c4043;
            --scrollbar-thumb: #5f6368;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 13px;
            color: var(--text);
            background-color: var(--bg);
            margin: 0;
            padding: 16px;
            overflow-x: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            overflow: hidden; /* For collapse animation */
            transition: background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                        border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Animation state to prevent rapid clicking */
        .card.animating {
            pointer-events: none;
        }

        .card-header {
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: transform 0.1s ease;
        }

        .card-header:hover {
            background-color: rgba(0,0,0,0.02);
        }
        [data-theme="dark"] .card-header:hover {
            background-color: rgba(255,255,255,0.02);
        }

        .card-title {
            font-weight: 600;
            font-size: 14px;
            padding-left: 8px;
            border-left: 3px solid var(--primary);
            line-height: 1;
            color: var(--text);
        }

        /* Collapsible Icon */
        .card-header::after {
            content: '';
            width: 0; 
            height: 0; 
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid var(--text-secondary);
            transition: transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Collapsed State */
        .card.collapsed .card-header::after {
            transform: rotate(-90deg);
        }

        /* 统一的动画效果：快速开始，缓慢结束 */
        .card-content {
            padding: 0 20px 20px 20px;
            max-height: 1000px;
            opacity: 1;
            /* 展开时：快速开始，缓慢结束 */
            transition: max-height 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s,
                        opacity 0.1s cubic-bezier(0.4, 0, 1, 1) 0.15s,
                        padding 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s;
        }

        /* 收起时：同样快速开始，缓慢结束 */
        .card.collapsed .card-content {
            max-height: 0;
            padding-bottom: 0;
            overflow: hidden;
            /* 收起时：快速开始，缓慢结束（相同缓动函数）*/
            transition: max-height 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s,
                        opacity 0.1s cubic-bezier(0.4, 0, 1, 1) 0s,
                        padding 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0s;
        }

        .setting-item {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-info {
            flex: 1;
            padding-right: 24px;
        }

        .setting-label {
            display: block;
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 4px;
            color: var(--text);
        }

        .setting-desc {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .setting-control {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
        }

        /* Input Groups */
        .input-group {
            display: flex;
            align-items: center;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--input-bg);
            overflow: hidden;
            width: 140px;
            transition: border-color 0.2s;
        }
        
        .input-group:focus-within {
            border-color: var(--primary);
        }

        .input-group input {
            border: none;
            padding: 8px 10px;
            width: 100%;
            outline: none;
            background: transparent;
            font-size: 13px;
            color: var(--text);
            text-align: right;
        }

        .input-group .addon {
            background: rgba(0,0,0,0.05);
            border: none;
            border-left: 1px solid var(--border);
            padding: 0 10px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            outline: none;
            font-weight: 500;
        }
        
        /* Toggle Switch */
        .switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .switch-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--switch-bg);
            transition: .3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid transparent;
            outline: none;
        }

        .btn-white {
            background: var(--card-bg);
            border-color: var(--border);
            color: var(--text);
        }

        .btn-white:hover {
            background: var(--bg);
            border-color: var(--text-secondary);
        }

        .btn-primary {
            background: var(--primary);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-danger {
            background: var(--card-bg);
            color: var(--danger);
            border-color: var(--danger);
            opacity: 0.8;
        }

        .btn-danger:hover {
            opacity: 1;
            background: rgba(220, 53, 69, 0.1);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }
        
        .btn-ghost:hover {
            background: var(--hover-bg);
            color: var(--text);
        }

        /* Snapshot specific */
        .filter-bar {
            display: flex;
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .filter-btn {
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: var(--card-bg);
            color: var(--primary);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            font-weight: 500;
        }

        .filter-btn.inactive {
            background: transparent;
            color: var(--text-secondary);
        }

        .snapshot-container {
            border: 1px solid var(--border);
            border-radius: 6px;
            min-height: 100px;
            max-height: 180px;
            overflow-y: auto;
            background: var(--bg);
            margin-top: 12px;
        }

        .snapshot-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100px;
            color: var(--text-hint);
            font-size: 12px;
        }

        .snapshot-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            background: var(--card-bg);
            transition: background 0.2s;
        }
        
        .snapshot-item:hover {
            background: var(--hover-bg);
        }
        
        .snapshot-item:last-child {
            border-bottom: none;
        }

        .snapshot-meta {
            font-weight: 500;
            font-size: 13px;
            margin-bottom: 2px;
            color: var(--text);
        }
        
        .snapshot-details {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .footer-status {
            margin-top: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #28a745;
            font-weight: 500;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 13px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, 10px);
        }
        
        .toast.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }

        /* Animation */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .rotating { animation: spin 0.6s cubic-bezier(0.4, 0.0, 0.2, 1) infinite; display: inline-block; pointer-events: none; }
    </style>
</head>
<body>

    <div class="card">
        <div class="card-header">
            <div class="card-title" data-i18n="过渡设置">过渡设置</div>
        </div>
        <div class="card-content">

            <!-- Radius -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="圆角半径比率">圆角半径比率</div>
                    <div class="setting-desc" data-i18n="半径 = 线宽 x 比率">半径 = 线宽 × 比率</div>
                </div>
                <div class="setting-control">
                    <div class="input-group">
                        <input type="text" id="cornerRadiusRatio" data-min="1" data-max="20" data-step="0.5" value="3.0">
                        <span class="addon">X</span>
                    </div>
                </div>
            </div>


            <!-- Sync Width -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="自动线宽过渡">自动线宽过渡</div>
                    <div class="setting-desc" data-i18n="圆滑后处理线宽突变处">圆滑后处理线宽突变处</div>
                </div>
                <div class="setting-control">
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="syncWidthTransition">
                            <span class="slider"></span>
                        </label>
                        <span class="switch-label" id="syncWidthLabel" data-i18n="启用">启用</span>
                    </div>
                </div>
            </div>

            <!-- Ratio -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="过渡长度比率">过渡长度比率</div>
                    <div class="setting-desc" data-i18n="过渡区长度比率说明">线宽过度区长度 = 线宽差 × 比率 (推荐 2.0)</div>
                </div>
                <div class="setting-control">
                    <div class="input-group">
                        <input type="text" id="widthTransitionRatio" data-min="1.0" data-max="5.0" data-step="0.1" value="2.0">
                        <span class="addon">X</span>
                    </div>
                </div>
            </div>
            
             <!-- Balance -->
             <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="过渡区位置">过渡区位置</div>
                    <div class="setting-desc" data-i18n="过渡区位置说明">0% = 全部向窄线延伸，100% = 全部向宽线延伸</div>
                </div>
                <div class="setting-control">
                    <div class="input-group">
                        <input type="text" id="widthTransitionBalance" data-min="0" data-max="100" data-step="5" value="50">
                        <span class="addon">%</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- DRC Settings -->
    <div class="card">
        <div class="card-header">
            <div class="card-title" data-i18n="设计规则检查 (DRC)">设计规则检查 (DRC)</div>
        </div>
        <!-- Enable DRC -->
        <div class="card-content">
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label">
                        <span data-i18n="自动避让/回滚">自动避让/回滚</span>
                        <span style="background:var(--bg);color:var(--primary);border:1px solid var(--primary);padding:1px 5px;border-radius:4px;font-size:10px;margin-left:6px;">Beta</span>
                    </div>
                    <div class="setting-desc" data-i18n="若圆角导致间距报错，自动尝试缩小半径">若圆角导致间距报错，自动尝试缩小半径</div>
                </div>
                <div class="setting-control">
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="enableDRC" checked>
                            <span class="slider"></span>
                        </label>
                        <span class="switch-label" id="enableDRCLabel" data-i18n="启用">启用</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Advanced -->
    <div class="card collapsed"> <div class="card-header">
            <div class="card-title" data-i18n="高级设置">高级设置</div>
        </div>

        <!-- Merge Short Segments -->
        <div class="card-content">
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label">
                        <span data-i18n="合并过渡线段">合并过渡线段</span>
                        <span style="background:var(--bg);color:var(--primary);border:1px solid var(--primary);padding:1px 5px;border-radius:4px;font-size:10px;margin-left:6px;">Beta</span>
                    </div>
                    <div class="setting-desc" data-i18n="自动合并中间的过渡线段以生成圆弧">自动合并中间的过渡线段以生成圆弧</div>
                </div>
                <div class="setting-control">
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="mergeTransitionSegments" checked>
                            <span class="slider"></span>
                        </label>
                        <span class="switch-label" id="mergeTransitionSegmentsLabel" data-i18n="启用">启用</span>
                    </div>
                </div>
            </div>

            <!-- Force Arc -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label">
                        <span data-i18n="强制生成圆弧">强制生成圆弧</span>
                        <span style="background:var(--bg);color:var(--primary);border:1px solid var(--primary);padding:1px 5px;border-radius:4px;font-size:10px;margin-left:6px;">Beta</span>
                    </div>
                    <div class="setting-desc" data-i18n="短线段导致圆弧不相切也生成（半径减小）">短线段导致圆弧不相切也生成（半径减小）</div>
                </div>
                <div class="setting-control">
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="forceArc" checked>
                            <span class="slider"></span>
                        </label>
                        <span class="switch-label" id="forceArcLabel" data-i18n="启用">启用</span>
                    </div>
                </div>
            </div>

            <!-- Segments -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="最大过渡段数">最大过渡段数</div>
                    <div class="setting-desc" data-i18n="防止段数过多导致卡顿">线宽过渡的最大段数，防止段数过多导致卡顿</div>
                </div>
                <div class="setting-control">
                    <div class="input-group">
                        <input type="text" id="widthTransitionSegments" data-min="5" data-max="100" data-step="1" value="25">
                        <span class="addon" data-i18n="段">段</span>
                    </div>
                </div>
            </div>

            <!-- Debug -->
            <div class="setting-item">
                <div class="setting-info">
                    <div class="setting-label" data-i18n="调试模式">调试模式</div>
                    <div class="setting-desc" data-i18n="启用调试日志">在日志栏打印</div>
                </div>
                <div class="setting-control">
                    <div class="switch-container">
                        <label class="switch">
                            <input type="checkbox" id="debug">
                            <span class="slider"></span>
                        </label>
                        <span class="switch-label" id="debugLabel" data-i18n="启用">启用</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

	<!-- Snapshot -->
    <div class="card">
        <div class="card-header">
            <div class="card-title">
                <span data-i18n="布线状态管理">布线状态管理</span>
                <span id="snapshotCount" style="font-weight: normal; color: var(--text-hint); font-size: 12px; margin-left: 4px;"></span>
            </div>
        </div>
        <div class="card-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div class="filter-bar">
                    <button id="btnShowManual" class="filter-btn active" data-i18n="手动快照">手动快照</button>
                    <button id="btnShowAuto" class="filter-btn inactive" data-i18n="自动快照">自动快照</button>
                    <div style="width: 1px; background: var(--border); margin: 2px 2px;"></div>
                    <button type="button" class="btn btn-ghost" id="refreshSnapshotBtn" style="padding: 4px 8px; font-size: 16px; line-height: 1; border-radius: 4px;" title="刷新列表"><span class="refresh-icon" style="display:inline-block">↻</span></button>
                </div>

                <div style="display: flex; gap: 8px;">
                    <button type="button" class="btn btn-primary" id="createSnapshotBtn" style="padding: 4px 12px; font-size: 12px;" data-i18n="新增快照">新增快照</button>
                    <button type="button" class="btn btn-danger" id="clearSnapshotsBtn" style="padding: 4px 12px; font-size: 12px;" data-i18n="清除手动">清除手动</button>
                </div>
            </div>

            <div id="snapshotList" class="snapshot-container">
                <div class="snapshot-placeholder" data-i18n="暂无快照">暂无快照</div>
            </div>
        </div>
    </div>

    <div class="footer-status">
        <div class="status-badge" id="saveStatus">
            <span style="font-size: 14px;"></span> 
            <span data-i18n="设置即时生效">设置即时生效</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; color: var(--text-hint); font-size: 12px;">
            <span><span data-i18n="作者">作者</span>: <span style="font-weight: 500; color: var(--text-secondary);">m-RNA</span></span>
            <span style="color: var(--border);">|</span>
            <a href="javascript:void(0)" onclick="openUrl('https://github.com/m-RNA/Easy_EDA_PCB_Beautify')" style="color: var(--primary); text-decoration: none; border-bottom: 1px dashed var(--primary);">GitHub</a>
        </div>
        <button type="button" class="btn btn-white" id="closeBtn" onclick="tryClose()" data-i18n="关闭" style="min-width: 120px;">关闭</button>
    </div>
    
    <div id="toast" class="toast">Settings Saved</div>

    <script>
		/* global eda */

        // Helper to find the API object
        function getEda() {
            if (typeof eda !== 'undefined')
                return eda;
            if (window.parent && typeof window.parent.eda !== 'undefined')
                return window.parent.eda;
            if (window.top && typeof window.top.eda !== 'undefined')
                return window.top.eda;
            return null;
        }
        
        const API = getEda();

        if (!API) {
            console.error('JLC EDA API not found!');
            // Show visible error
            const errDiv = document.createElement('div');
            errDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;padding:10px;background:#ffebee;color:#c62828;text-align:center;z-index:9999;border-bottom:1px solid #ef9a9a;';
            errDiv.textContent = 'Error: Cannot connect to JLC EDA API. Please try reloading the extension.';
            document.body.prepend(errDiv);
        }

        // Apply Theme logic
        async function applyTheme() {
            const api = API || getEda();
            if (api && api.sys_Window && api.sys_Window.getCurrentTheme) {
                try {
                    const theme = await api.sys_Window.getCurrentTheme();
                    if (theme === 'dark') {
                        document.documentElement.setAttribute('data-theme', 'dark');
                    } else {
                        document.documentElement.removeAttribute('data-theme');
                    }
                } catch (e) {
                    console.warn('Failed to get theme', e);
                }
            }
        }

        // Bind Collapsible Cards with enhanced animation
        function bindCollapsibleCards() {
            const headers = document.querySelectorAll('.card-header');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const card = header.closest('.card');
                    if (card) {
                        // Prevent multiple rapid clicks
                        if (card.classList.contains('animating')) return;
                        
                        card.classList.add('animating');
                        card.classList.toggle('collapsed');
                        
                        // Remove animating class after animation completes
                        setTimeout(() => {
                            card.classList.remove('animating');
                        }, 250); // 匹配CSS动画时长0.25s
                    }
                });
            });
        }

        function tryClose() {
            const api = API || getEda();
            if (api && api.sys_IFrame && api.sys_IFrame.closeIFrame) {
                api.sys_IFrame.closeIFrame('settings');
            }
            else {
                console.log('Close requested (API missing)');
            }
        }

        function openUrl(url) {
            const api = API || getEda();
            if (api && api.sys_Window && typeof api.sys_Window.openUrl === 'function') {
                api.sys_Window.openUrl(url);
            } else {
                window.open(url, '_blank');
            }
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);
        }

        function translatePage() {
            const api = API || getEda();
            if (!api || typeof api.sys_I18n === 'undefined')
                return;

            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach((el) => {
                const key = el.getAttribute('data-i18n');
                if (key) {
                    const text = api.sys_I18n.text(key);
                    if (text && text !== key) {
                        if (el.tagName === 'INPUT' && el.type === 'placeholder') {
                            el.placeholder = text;
                        }
                        else {
                            // Don't overwrite if it has children like the switch slider, unless it's just text
                            if (el.children.length === 0) {
                                el.textContent = text;
                            }
                            // 特殊处理某些元素的属性
                            else if (el.hasAttribute('title')) {
                                el.setAttribute('title', text);
                            }
                        }
                    }
                    // 如果翻译失败，保持原文本不变
                }
            });
            
            // 翻译页面标题
            document.title = api.sys_I18n.text('设置');
        }

        // Elements
        const elCornerRadiusRatio = document.getElementById('cornerRadiusRatio');
        const elSyncWidth = document.getElementById('syncWidthTransition');
        const elSegments = document.getElementById('widthTransitionSegments');
        const elRatio = document.getElementById('widthTransitionRatio');
        const elDirection = document.getElementById('widthTransitionBalance');
        const elDebug = document.getElementById('debug');
        const elForceArc = document.getElementById('forceArc');
        const elMergeTransitionSegments = document.getElementById('mergeTransitionSegments');
        const elEnableDRC = document.getElementById('enableDRC');

        // I18n labels update
        const elSyncWidthLabel = document.getElementById('syncWidthLabel');
        const elDebugLabel = document.getElementById('debugLabel');
        const elMergeTransitionSegmentsLabel = document.getElementById('mergeTransitionSegmentsLabel');
        const elForceArcLabel = document.getElementById('forceArcLabel');
        const elEnableDRCLabel = document.getElementById('enableDRCLabel');

        // 默认配置 (将在 init 中从 API 获取)
        let DEFAULT_CONFIG = {};

        function updateSwitchLabels() {
            const api = API || getEda();
            const enabledText = (api && api.sys_I18n) ? api.sys_I18n.text('启用') : '启用';
            const disabledText = (api && api.sys_I18n) ? api.sys_I18n.text('禁用') : '禁用';

            elSyncWidthLabel.textContent = elSyncWidth.checked ? enabledText : disabledText;
            elDebugLabel.textContent = elDebug.checked ? enabledText : disabledText;
            elMergeTransitionSegmentsLabel.textContent = elMergeTransitionSegments.checked ? enabledText : disabledText;
            elForceArcLabel.textContent = elForceArc.checked ? enabledText : disabledText;
            elEnableDRCLabel.textContent = elEnableDRC.checked ? enabledText : disabledText;

            // Visual feedback color for label
            elSyncWidthLabel.style.color = elSyncWidth.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elDebugLabel.style.color = elDebug.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elMergeTransitionSegmentsLabel.style.color = elMergeTransitionSegments.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elForceArcLabel.style.color = elForceArc.checked ? 'var(--primary)' : 'var(--text-secondary)';
            elEnableDRCLabel.style.color = elEnableDRC.checked ? 'var(--primary)' : 'var(--text-secondary)';
        }

        // Load
        async function loadSettings() {
            const api = API || getEda();
            if (!api)
                return;

            // 尝试同步默认配置配置
            if (typeof api.jlc_eda_beautify_getDefaultSettings === 'function') {
                try {
                    DEFAULT_CONFIG = api.jlc_eda_beautify_getDefaultSettings();
                    console.log('Loaded defaults from API', DEFAULT_CONFIG);
                }
                catch (e) {
                    console.error('Failed to load defaults', e);
                }
            }

            try {
                const settings = await api.sys_Storage.getExtensionAllUserConfigs() || {};
                const config = {
                    ...DEFAULT_CONFIG,
                    ...settings,
                };

                if (elCornerRadiusRatio) {
                    elCornerRadiusRatio.value = config.cornerRadiusRatio;
                    elCornerRadiusRatio.setAttribute('data-last-valid', config.cornerRadiusRatio);
                }

                if (elMergeTransitionSegments) elMergeTransitionSegments.checked = config.mergeTransitionSegments !== undefined ? config.mergeTransitionSegments : true;
                if (elSyncWidth) elSyncWidth.checked = config.syncWidthTransition;

                if (elSegments) {
                    elSegments.value = config.widthTransitionSegments;
                    elSegments.setAttribute('data-last-valid', config.widthTransitionSegments);
                }

                if (elRatio) {
                    elRatio.value = config.widthTransitionRatio;
                    elRatio.setAttribute('data-last-valid', config.widthTransitionRatio);
                }

                if (elDirection) {
                    elDirection.value = config.widthTransitionBalance !== undefined ? config.widthTransitionBalance : 50;
                    elDirection.setAttribute('data-last-valid', elDirection.value);
                }

                if (elDebug) elDebug.checked = config.debug;
                if (elForceArc) elForceArc.checked = config.forceArc !== undefined ? config.forceArc : true;
                if (elEnableDRC) elEnableDRC.checked = config.enableDRC !== undefined ? config.enableDRC : false;

                updateSwitchLabels();
            }
            catch (e) {
                console.error(e);
            }
        }

        // 改进的保存函数，添加错误处理和用户反馈
        async function saveSettings(silent = false) {
            const api = API || getEda();
            if (!api)
                return false;

            // Validate numbers
            let radiusRatio = Number.parseFloat(elCornerRadiusRatio.value);
            if (Number.isNaN(radiusRatio))
                radiusRatio = DEFAULT_CONFIG.cornerRadiusRatio;

            let segments = Number.parseInt(elSegments.value);
            if (Number.isNaN(segments) || segments < 1)
                segments = DEFAULT_CONFIG.widthTransitionSegments;

            let ratio = Number.parseFloat(elRatio.value);
            if (Number.isNaN(ratio))
                ratio = DEFAULT_CONFIG.widthTransitionRatio;

            const settings = {
                cornerRadiusRatio: radiusRatio,
                mergeTransitionSegments: elMergeTransitionSegments.checked,
                syncWidthTransition: elSyncWidth.checked,
                widthTransitionSegments: segments,
                widthTransitionRatio: ratio,
                widthTransitionBalance: elDirection ? Number(elDirection.value) : 50,
                debug: elDebug.checked,
                forceArc: elForceArc.checked,
                enableDRC: elEnableDRC.checked,
            };

            try {
                await api.sys_Storage.setExtensionAllUserConfigs(settings);
                updateSwitchLabels();

                // 通知插件主进程刷新设置缓存
                if (typeof api.jlc_eda_beautify_refreshSettings === 'function') {
                    await api.jlc_eda_beautify_refreshSettings();
                }

                if (!silent) {
                    const msg = api.sys_I18n ? api.sys_I18n.text('已保存') : 'Saved';
                    showToast(msg);
                }
                
                return true;
            }
            catch (e) {
                console.error('Save failed:', e);
                if (!silent && api && api.sys_Dialog) {
                    const errorMsg = api.sys_I18n ? api.sys_I18n.text('保存失败') : 'Save failed';
                    api.sys_Dialog.showInformationMessage(`${errorMsg}: ${e.message || e}`);
                }
                return false;
            }
        }

        // Bind Events
        function bindSmartInput(el, isInt = false) {
            if (!el) return;

            function validateAndSave() {
                let val = el.value.trim();
                if (!val) {
                    el.value = el.getAttribute('data-last-valid') || (isInt ? '0' : '0.0');
                    return;
                }

                // Check for math operators (Supports +, -, *, /, ())
                if (/[+\-*/]/.test(val)) {
                    try {
                        // Security check: strictly limit allowed characters
                        if (/^[0-9.+\-*/()\s]+$/.test(val)) {
                            // eslint-disable-next-line no-new-func
                            let result = new Function(`return ${val}`)();
                            if (Number.isFinite(result)) {
                                if (isInt) {
                                    result = Math.round(result);
                                }
                                else {
                                    // Allow up to 3 decimal places
                                    result = Number.parseFloat(result.toFixed(3));
                                }
                                el.value = result;
                                val = String(result);
                            }
                            else {
                                // Calculation resulted in error/infinity, revert
                                el.value = el.getAttribute('data-last-valid');
                                return;
                            }
                        }
                        else {
                            // Illegal characters found, revert
                            el.value = el.getAttribute('data-last-valid');
                            return;
                        }
                    }
                    catch {
                        // Eval failed, revert
                        el.value = el.getAttribute('data-last-valid');
                        return;
                    }
                }

                let num = Number.parseFloat(val);

                if (Number.isNaN(num)) {
                    el.value = el.getAttribute('data-last-valid');
                    return;
                }

                const min = Number.parseFloat(el.getAttribute('data-min') || '-99999999');
                const max = Number.parseFloat(el.getAttribute('data-max') || '99999999');

                if (num < min)
                    num = min;
                if (num > max)
                    num = max;

                if (isInt) {
                    num = Math.round(num);
                }
                else {
                    // Normalize to max 3 decimals
                    num = Number.parseFloat(num.toFixed(3));
                }

                el.value = num;

                // Check if actually changed to avoid redundant saves
                const last = Number.parseFloat(el.getAttribute('data-last-valid'));
                if (num !== last) {
                    el.setAttribute('data-last-valid', num);
                    saveSettings();
                }
            }

            // Unified step logic
            function applyStep(direction, multiplier) {
                // Don't step if current value is formula
                let val = el.value.trim();
                if (/[+\-*/]/.test(val)) {
                    validateAndSave();
                    val = el.value.trim();
                }

                let num = Number.parseFloat(val);
                if (Number.isNaN(num))
                    num = 0;

                let step = Number.parseFloat(el.getAttribute('data-step') || '1');
                if (Number.isNaN(step))
                    step = 1;

                step *= multiplier;

                if (direction > 0)
                    num += step; // up
                else num -= step; // down

                const min = Number.parseFloat(el.getAttribute('data-min') || '-99999999');
                const max = Number.parseFloat(el.getAttribute('data-max') || '99999999');

                if (num < min)
                    num = min;
                if (num > max)
                    num = max;

                if (isInt) {
                    num = Math.round(num);
                }
                else {
                    num = Number.parseFloat(num.toFixed(3));
                }

                el.value = num;
                el.setAttribute('data-last-valid', num);

                // Debounce save for rapid wheel/key events
                if (el.saveTimer)
                    clearTimeout(el.saveTimer);
                el.saveTimer = setTimeout(() => {
                    saveSettings();
                }, 500);
            }

            // Handle Keyboard stepping (Up/Down) since type="text" doesn't have it natively
            function handleKeyDown(e) {
                if (e.key === 'Enter') {
                    el.blur();
                    return;
                }

                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    applyStep(e.key === 'ArrowUp' ? 1 : -1, e.shiftKey ? 10 : 1);
                }
            }

            // Handle Mouse Wheel
            function handleWheel(e) {
                if (document.activeElement !== el)
                    return;
                e.preventDefault();
                // deltaY < 0 means scrolling up (increment)
                applyStep(e.deltaY < 0 ? 1 : -1, e.shiftKey ? 10 : 1);
            }

            el.addEventListener('change', validateAndSave);
            el.addEventListener('blur', validateAndSave);
            el.addEventListener('keydown', handleKeyDown);
            el.addEventListener('wheel', handleWheel, { passive: false });
        }

        // Apply bindings
        bindSmartInput(elCornerRadiusRatio, false);
        bindSmartInput(elSegments, true);
        bindSmartInput(elRatio, false);
        bindSmartInput(elDirection, true);

        [elSyncWidth, elDebug, elMergeTransitionSegments, elForceArc, elEnableDRC].forEach((el) => {
            if (el) el.addEventListener('change', () => saveSettings());
        });

        const closeBtn = document.getElementById('closeBtn');
        if (closeBtn) closeBtn.addEventListener('click', tryClose);

        // Snapshots logic
        const snapshotList = document.getElementById('snapshotList');
        let currentPcbId = null;

        // 定期检查 PCB 切换
        // View Mode State
        let currentViewType = 'manual';

        async function checkPcbChange() {
            const api = API || getEda();
            if (!api || !api.dmt_Pcb) return;
            try {
                let pid = null;
                const info = await api.dmt_Pcb.getCurrentPcbInfo();
                if (info) pid = info.uuid;
                else {
                    const boardInfo = await api.dmt_Board.getCurrentBoardInfo();
                    if (boardInfo && boardInfo.pcb) pid = boardInfo.pcb.uuid;
                }

                if (pid && pid !== currentPcbId) {
                    currentPcbId = pid;
                    
                    // 自动刷新动画
                    const btn = document.getElementById('refreshSnapshotBtn');
                    const icon = btn ? btn.querySelector('.refresh-icon') : null;
                    if (icon) {
                        icon.classList.add('rotating');
                        setTimeout(() => icon.classList.remove('rotating'), 600);
                    }

                    refreshSnapshots(); // PCB 改变，刷新列表
                }
            } catch (e) { /* ignore */ }
        }
        setInterval(checkPcbChange, 2000);

        // Toggle Buttons
        const btnShowManual = document.getElementById('btnShowManual');
        const btnShowAuto = document.getElementById('btnShowAuto');

        function updateToggleStyles() {
            if (currentViewType === 'manual') {
                btnShowManual.className = 'filter-btn active';
                btnShowAuto.className = 'filter-btn inactive';
            } else {
                btnShowAuto.className = 'filter-btn active';
                btnShowManual.className = 'filter-btn inactive';
            }
        }

        if (btnShowManual && btnShowAuto) {
            btnShowManual.onclick = () => {
                if (currentViewType !== 'manual') {
                    currentViewType = 'manual';
                    updateToggleStyles();
                    refreshSnapshots();
                }
            };

            btnShowAuto.onclick = () => {
                if (currentViewType !== 'auto') {
                    currentViewType = 'auto';
                    updateToggleStyles();
                    refreshSnapshots();
                }
            };
        }

        async function refreshSnapshots() {
            const api = API || getEda();
            if (!api || !api.jlc_eda_beautify_snapshot)
                return;
                
            try {
                // 确保我们有当前的 PCB ID
                if (!currentPcbId) {
                   await checkPcbChange();
                }

                if (!currentPcbId) {
                     // 依然没有 PCB，可能是没打开文档
                     snapshotList.innerHTML = `<div class="snapshot-placeholder">${api.sys_I18n ? api.sys_I18n.text('请先打开PCB文档') : 'Please open a PCB'}</div>`;
                     const countEl = document.getElementById('snapshotCount');
                     if (countEl) countEl.textContent = `(0/0)`;
                     return;
                }

                // 根据当前视图模式获取快照
                const snapshots = await api.jlc_eda_beautify_snapshot.getSnapshots(currentPcbId, currentViewType);

                // Update Count safely
                const countEl = document.getElementById('snapshotCount');
                // 获取限制数量，默认为 20
                const limit = (api.jlc_eda_beautify_snapshot && api.jlc_eda_beautify_snapshot.SNAPSHOT_LIMIT) ? api.jlc_eda_beautify_snapshot.SNAPSHOT_LIMIT : 20;

                if (countEl)
                    countEl.textContent = `(${snapshots.length}/${limit})`;

                // Fix: Sync the poller counter to avoid double-refresh on view toggle
                if (currentViewType === 'auto') {
                    lastSnapshotCount = snapshots.length;
                }

                snapshotList.innerHTML = '';
                if (snapshots.length === 0) {
                    const emptyText = api.sys_I18n ? api.sys_I18n.text('暂无快照') : '暂无快照';
                    snapshotList.innerHTML = `<div class="snapshot-placeholder">${emptyText}</div>`;
                    return;
                }

                const sorted = snapshots;
                // 获取最后一次恢复的 ID
                const lastRestoredId = api.jlc_eda_beautify_snapshot.getLastRestoredId ? api.jlc_eda_beautify_snapshot.getLastRestoredId() : null;

                sorted.forEach((snap, index) => {
                    const div = document.createElement('div');
                    div.className = 'snapshot-item';

                    const timeStr = new Date(snap.timestamp).toLocaleTimeString();
                    let nameStr = snap.name;
                    if (!nameStr) {
                        nameStr = api.sys_I18n ? api.sys_I18n.text('自动快照') : 'Automatic Snapshot';
                    }
                    else if (api.sys_I18n && (nameStr === '手动快照' || nameStr === 'Manual Snapshot')) {
                        nameStr = api.sys_I18n.text(nameStr);
                    }

                    // 如果是最后一次撤销的快照，添加标记 (使用 == 进行宽松比较，避免类型问题)
                    let badgeHtml = '';

                    const isLastRestored = lastRestoredId !== null && String(snap.id) === String(lastRestoredId);
                    if (isLastRestored) {
                        const undoText = api.sys_I18n ? api.sys_I18n.text('上次撤销至此') : 'Last Undo Point';
                        badgeHtml += `<span style="background:var(--bg);color:var(--primary);border:1px solid var(--primary);padding:1px 5px;border-radius:4px;font-size:10px;margin-left:6px;">${undoText}</span>`;
                    }

                    // 如果是最新的快照
                    if (index === 0) {
                        const latestText = api.sys_I18n ? api.sys_I18n.text('最新') : 'Latest';
                        badgeHtml += `<span style="background:var(--bg);color:#2e7d32;border:1px solid #2e7d32;padding:1px 5px;border-radius:4px;font-size:10px;margin-left:6px;">${latestText}</span>`;
                    }

                    const recoverText = api.sys_I18n ? api.sys_I18n.text('恢复') : 'Recover';
                    const deleteText = api.sys_I18n ? api.sys_I18n.text('删除') : 'Del';
                    const linesCount = snap.lines ? snap.lines.length : 0;
                    const arcsCount = snap.arcs ? snap.arcs.length : 0;
                    const linesText = `${linesCount} Lines, ${arcsCount} Arcs`;

                    div.innerHTML = `
                        <div style="flex:1;overflow:hidden;">
                            <div class="snapshot-meta">${nameStr}${badgeHtml}</div>
                            <div class="snapshot-details">${timeStr} · ${linesText}</div>
                        </div>
                        <div style="display:flex;gap:4px;">
                            <button type="button" class="btn btn-white btn-recover" style="padding:4px 10px;font-size:12px;">${recoverText}</button>
                            <button type="button" class="btn btn-ghost btn-delete" style="padding:4px 8px;font-size:12px;color:var(--danger);" title="${deleteText}">✕</button>
                        </div>
                    `;

                    // Recover Button
                    div.querySelector('.btn-recover').onclick = async () => {
                        // 直接调用恢复，参数3传 true 表示需要后端弹窗确认 (或者由后端处理 ID 不匹配警告)
                        // 这样避免在 UI 线程和后端线程同时发起弹窗导致冲突
                        try {
                            const result = await api.jlc_eda_beautify_snapshot.restoreSnapshot(snap.id, true, true);
                            if (result) {
                                const restoredText = api.sys_I18n ? api.sys_I18n.text('已恢复') : 'Restored';
                                showToast(restoredText);
                            }
                        }
                        catch (err) {
                            api.sys_Dialog.showInformationMessage(`Restore failed: ${err}`);
                        }
                    };

                    // Delete Button
                    div.querySelector('.btn-delete').onclick = (e) => {
                        e.stopPropagation(); // 阻止冒泡
                        const confirmDelText = api.sys_I18n ? api.sys_I18n.text('确定要删除此快照吗？') : 'Delete this snapshot?';
                        if (api.sys_Dialog) {
                            api.sys_Dialog.showConfirmationMessage(confirmDelText, api.sys_I18n ? api.sys_I18n.text('删除快照') : 'Delete Snapshot', undefined, undefined, async (ok) => {
                                if (ok) {
                                    await api.jlc_eda_beautify_snapshot.deleteSnapshot(snap.id);
                                }
                            });
                        }
                    };

                    snapshotList.appendChild(div);
                });
            }
            catch (e) {
                console.error('Snapshot refresh error:', e);
                snapshotList.innerHTML = '<div style="padding:10px;color:red">Error loading snapshots</div>';
            }
        }

        const btnRefresh = document.getElementById('refreshSnapshotBtn');
        if (btnRefresh) {
            btnRefresh.onclick = async function() {
                const btn = this;
                const icon = btn.querySelector('.refresh-icon'); 
                if (icon) icon.classList.add('rotating');
                
                try {
                    // 强制检查一次 PCB ID 变化
                    await checkPcbChange();
                    await refreshSnapshots();
                }
                finally {
                    // 至少转 600ms (正好一圈)
                    setTimeout(() => {
                        if (icon) icon.classList.remove('rotating');
                    }, 600);
                }
            };
        }

        const btnCreate = document.getElementById('createSnapshotBtn');
        if (btnCreate) {
            btnCreate.onclick = async () => {
                const api = API || getEda();
                if (!api || !api.jlc_eda_beautify_snapshot) return;
                try {
                    const name = api.sys_I18n ? api.sys_I18n.text('手动快照') : 'Manual Snapshot';
                    await api.jlc_eda_beautify_snapshot.createSnapshot(name, true);
                    await refreshSnapshots();
                    showToast(api.sys_I18n ? api.sys_I18n.text('快照已创建') : 'Snapshot Created');
                }
                catch (e) {
                    console.error('Create Snapshot Error:', e);
                }
            };
        }

        const btnClear = document.getElementById('clearSnapshotsBtn');
        if (btnClear) {
            btnClear.onclick = () => {
                const api = API || getEda();
                if (!api || !api.jlc_eda_beautify_snapshot)
				    return;
                const confirmText = api.sys_I18n ? api.sys_I18n.text('确定要清除所有手动快照吗？') : 'Clear all manual snapshots?';

                if (api.sys_Dialog) {
                    api.sys_Dialog.showConfirmationMessage(confirmText, api.sys_I18n ? api.sys_I18n.text('清除手动快照') : 'Clear Manual Snapshots', undefined, undefined, async (ok) => {
                        if (ok) {
                            await api.jlc_eda_beautify_snapshot.clearSnapshots();
                            await refreshSnapshots();
                            showToast(api.sys_I18n ? api.sys_I18n.text('已清除') : 'Cleared');
                        }
                    });
                }
            };
        }

        // Init
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        }
        else {
            init();
        }

        // Global for polling
        let lastSnapshotCount = -1;

        async function init() {
            try {
                // Load Settings first
                await loadSettings();
                
                // Initialize UI components
                bindCollapsibleCards();
                applyTheme();
                translatePage();
                
                // Load Snapshots
                refreshSnapshots();

                // 注册快照变化回调，当主代码创建/删除快照时自动刷新列表
                const api = API || getEda();
                if (api && api.jlc_eda_beautify_snapshot && typeof api.jlc_eda_beautify_snapshot.registerSnapshotChangeCallback === 'function') {
                    // 使用新版显式注册接口
                    api.jlc_eda_beautify_snapshot.registerSnapshotChangeCallback(() => {
                        refreshSnapshots().catch((err) => {
                            console.error('[Settings] Snapshot refresh failed:', err);
                        });
                    });
                }

                // 额外保险：定时轮询检查快照数量变化
                const poller = async () => {
                    // 如果是手动模式，不轮询
                    if (currentViewType === 'manual') return;

                    const currentApi = API || getEda();
                    if (!currentApi || !currentApi.jlc_eda_beautify_snapshot || !currentPcbId)
                        return;

                    try {
                        const snapshots = await currentApi.jlc_eda_beautify_snapshot.getSnapshots(currentPcbId, 'auto');

                        // 只有数量变化时才重绘列表
                        if (snapshots.length !== lastSnapshotCount && lastSnapshotCount !== -1) {
                            refreshSnapshots();
                        }
                        lastSnapshotCount = snapshots.length;
                    }
                    catch { }
                };

                // 启动轮询 (2秒一次)
                setInterval(poller, 2000);
                
            } catch (error) {
                console.error('Settings initialization failed:', error);
                const api = API || getEda();
                if (api && api.sys_Dialog) {
                    const errorMsg = api.sys_I18n ? api.sys_I18n.text('初始化失败') : 'Initialization failed';
                    api.sys_Dialog.showInformationMessage(`${errorMsg}: ${error.message || error}`);
                }
            }
        }

	</script>
</body>
</html>